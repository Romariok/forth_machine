# Лабораторная работа №3. Эксперимент
Кобелев Роман, P3212 без усложнения
## Цель:

- экспериментальное знакомство с устройством процессоров через моделирование;
- получение опыта работы с компьютерной системой на нескольких уровнях организации, разрешая противоречия между ними.

## Данная лабораторная работа носит практический характер. Она включает разработку:

- языка программирования и транслятора;
- системы команд;
- модели процессора и его принципиальной схемы;
- нескольких алгоритмов (реализация и тестирование работы).

## Дополнительно:

- работа с CI;
- средства автоматического контроля качества кода;
- автоматическое тестирование.

# Вариант
`forth | stack | harv | mc | tick | struct | stream | port | pstr | prob2`

`forth` - синтаксис языка Forth с обратной польской нотацией.

`stack` - система команд должна быть стековой:

- вместо регистров используется стек;
- это не исключает и не заменяет наличие памяти команд и памяти данных.

`harv` - Гарвардская архитектура:

- в тестах необходимо привести/проверить как память команд, так и память данных.

`mc` - microcoded.

- В отчёте необходимо задокументировать уровень микроинструкций.
-  Моделирование должно выполняться с точностью до такта.
- Микрокод должен быть сохранён в отдельной памяти для микропрограмм.
- Модель процессора должна исполнять микрокод.
- Точность модели -- потактовая (`tick`).

`tick` - процессор необходимо моделировать с точностью до такта, процесс моделирования может быть приостановлен на любом такте.

`struct` - в виде высокоуровневой структуры данных. Считается, что одна инструкция укладывается в одно машинное слово, за исключением CISC архитектур.

`stream` - Ввод-вывод осуществляется как поток токенов. Есть в примере. Логика работы:

- при старте модели у вас есть буфер, в котором представлены все данные ввода (['h', 'e', 'l', 'l', 'o']);
- при обращении к вводу (выполнение инструкции) модель процессора получает "токен" (символ) информации;
- если данные в буфере кончились -- останавливайте моделирование;
- вывод данных реализуется аналогично, по выполнении команд в буфер вывода добавляется ещё один символ;
- по окончании моделирования показать все выведенные данные;
- логика работы с буфером реализуется в рамках модели на Python.

`port` - port-mapped (специальные инструкции для ввода-вывода)

- адресация портов ввода-вывода должна присутствовать.

`prob2` - Even Fibonacci numbers
Project Euler. Problem 2

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

# Язык программирования
По варианту нужно реализовать FORTH-подобный язык

```
<program> ::= <definition>*
<definition> ::= <word-definition> | <variable-definition> | <constant-definition>
<word-definition> ::= ":" <word-name> <body> ";" | ":NONAME" <body> ";"
<word-name> ::= <identifier>
<body> ::= <word>*
<word> ::= <literal> | <primitive> | <word-name> | <conditional> | <loop> | <leave> | <comparsion>
<literal> ::= <number> | <string>
<number> ::= <digit>+
<string> ::= "'" <char>* "'"
<primitive> ::= "+" | "-" | "*" | "/" | "." | "@" | "!" | "@+!"
<variable-definition> ::= "VARIABLE" <word-name>
<constant-definition> ::= "CONSTANT" <word-name> <number>
<conditional> ::= "IF" <body>
<condition> ::= <number> | <literal>
<loop> ::= "DO" <body> "LOOP"
<leave> ::= "LEAVE"
<comparison> ::= "<" | ">" | "="
<identifier> ::= <letter> (<letter> | <digit>)*
<letter> ::= "A" | "B" | ... | "Z" | "a" | "b" | ... | "z"
<digit> ::= "0" | "1" | ... | "9"
```
`any number` - Записываем в стек число

`variable <name> <value>` - Приисвоить переменной с именем `<name>` значение `<value>`

`+` - Вынимает два последних значения в стеке и записывает результат их сложения

`-` - Вынимает два последних значения в стеке и записывает результат вычитания из предпоследнего элемента последнего 

`*` - Вынимает два последних значения в стеке и записывает результат их перемножения

`/` - Вынимает два последних значения в стеке и записывает результат деления из предпоследнего элемента последнего 

`.` - Вынимает последний элемент из стека и выводит его

`< > =` - Идёт сравнение предпоследжнего элемента стека с последним и записывается `0`, если не выполняется условие и `-1`, если выполняется

`:_start` - задание основной функции

`;` - `HLT`

`!` - помещает значение и ячейку памяти в стек и сохраняет это значение в этой ячейке памяти

`@` - извлекает значение на основе расположения в памяти и помещает это значение в стек

`do loop` - условный оператор, напоминающий конструкцию `for` в большинтсве языков на основе `C`. специальное слово `i` помещает текущий индекс цикла в стек. Два верхних значения в стеке дают начальное значение (включительно) и конечное значение (исключая) для значения `i`. Начальное значение берется с вершины стека.

`leave` - выход из цикла

`@+!` - добавить и назначить

`if <expression>` - сравнивает значение регистра с указанным значением и устанавливает значение статуса

`#<any number>` - прямая загрузка числа в память
# Организация памяти
Так как у меня Гарвардская архитектура, то у меня память данных и память инструкций будут разделены

# Система команд
- Машинное слово - 16 бит
```yaml
instruction:
   instr_index: 0
   op_code: 0
```
# Control Unit
Занимается декодированием микрокоманд

Листинг микрокоманд:

```

```

